# Unity GPU Skinning Tool 项目实现思路分析

## 一、项目概述

本项目是一个基于 Unity 2021.3.0f1 Universal RP 实现的 GPU 骨骼蒙皮插件。其核心思想是**将传统 CPU 上进行的骨骼动画蒙皮计算转移到 GPU 上执行**，从而提升大量相同模型的动画渲染性能。

## 二、核心实现原理

### 2.1 基本原理

传统的骨骼动画是在 CPU 上每帧计算骨骼变换矩阵，然后应用到每个顶点上。这个项目的创新点在于：

1. **预计算**：在编辑器阶段将骨骼动画的所有帧的骨骼矩阵提前计算出来
2. **纹理存储**：将这些骨骼矩阵数据编码并存储到纹理中
3. **GPU 采样**：运行时在 Shader 中通过采样动画纹理获取骨骼矩阵
4. **GPU 蒙皮**：在 Vertex Shader 中完成顶点的蒙皮计算

### 2.2 骨骼矩阵计算公式

```
骨骼矩阵 = boneNode.localToWorldMatrix * boneBindPose
```

这个公式包含两个步骤：
1. **模型空间 → 骨骼空间**：通过 boneBindPose（记录在 Mesh 中的绑定姿势）将顶点从模型空间转换到骨骼节点的坐标系
2. **骨骼空间 → 模型空间**：通过 bone.localToWorldMatrix（记录了骨骼在播放动画时的变换）将顶点转回模型空间

## 三、技术实现细节

### 3.1 数据结构设计

#### GpuSkinningAnimData（动画数据）
```csharp
public class GpuSkinningAnimData : ScriptableObject
{
    public int texWidth;        // 动画纹理宽度
    public int texHeight;       // 动画纹理高度
    public GpuSkinningAnimClip[] clips;  // 动画片段数组
    public int totalFrame;      // 总帧数
    public int totalBoneNum;    // 骨骼数量
    public float min;           // 数据范围最小值
    public float max;           // 数据范围最大值
}
```

#### GpuSkinningAnimClip（动画片段）
```csharp
public class GpuSkinningAnimClip
{
    public string name;         // 动画名称
    public int startFrame;      // 起始帧
    public int endFrame;        // 结束帧
    public float frameRate;     // 帧率
}
```

### 3.2 动画纹理编码方案

项目支持两种动画类型：

#### 1. 骨骼动画（Skeleton Animation）
- **存储内容**：每根骨骼的变换矩阵（旋转 + 位移 + 缩放）
- **纹理格式**：RGBAHalf（每通道 16 位浮点数）
- **存储方式**：
  - 每根骨骼每帧占用 2 个像素
  - 像素 1：存储四元数旋转（rotation.xyzw）
  - 像素 2：存储位移（translation.xyz）和缩放（scale.magnitude）
- **纹理大小计算**：
  ```
  totalPixels = boneNum × 2 × totalFrames
  根据 totalPixels 计算合适的纹理宽高（从 32×32 开始，按 2 的幂次递增）
  ```

#### 2. 顶点动画（Vertices Animation）
- **存储内容**：每个顶点在每帧的世界位置和法线
- **纹理格式**：RGBAHalf
- **存储方式**：
  - 位置纹理：每个顶点每帧占用 1 个像素存储位置（xyz）
  - 法线纹理：每个顶点每帧占用 1 个像素存储法线（xyz）
- **纹理大小**：
  ```
  texWidth = vertexCount
  texHeight = totalFrames
  ```

### 3.3 数据生成流程

#### 编辑器工具流程（GpuSkinningInstGenerator）

1. **骨骼重排序**（resortBone）
   - 遍历所有 SkinnedMeshRenderer 的骨骼
   - 建立骨骼 Transform 到全局骨骼 ID 的映射

2. **网格重建**（rebuildAllMeshes）
   - 复制原始 Mesh
   - 将骨骼索引存储到 UV1 通道（boneIndices）
   - 将骨骼权重存储到 UV2 通道（boneWeights）
   - 记录每根骨骼的 bindPose 矩阵

3. **动画采样**（samplerAnimationClipBoneMatrices）
   - 对每个动画片段的每一帧进行采样
   - 使用 AnimationClip.SampleAnimation 获取骨骼变换
   - 计算骨骼矩阵：`bone.localToWorldMatrix × bindPose`

4. **纹理生成**
   - **骨骼动画**（generateTexAndMesh）：
     - 提取骨骼矩阵的旋转（转换为四元数）
     - 提取位移和缩放
     - 编码到纹理像素中
   
   - **顶点动画**（generateTexAndMesh_verticesAnim）：
     - 对每个顶点应用骨骼变换：
       ```
       position = Σ(boneMatrix[i] × weight[i]) × vertex
       ```
     - 将计算后的顶点位置和法线存入纹理
     - 可选择某个动画帧作为 Mesh 的静态顶点数据

5. **材质和 Prefab 生成**
   - 创建使用对应 Shader 的材质
   - 绑定动画纹理和主纹理
   - 生成包含 MeshFilter、MeshRenderer 和动画控制组件的 Prefab

### 3.4 Shader 实现

#### 骨骼动画 Shader（GpuSkinningAnimation.shader）

**顶点着色器核心逻辑**：
```hlsl
// 1. 获取骨骼索引和权重（从 UV1 和 UV2）
float4 boneIndices = input.boneIndices;
float4 boneWeights = input.boneWeights;

// 2. 计算当前帧的骨骼数据在纹理中的起始位置
int frameDataPixelIndex = _BoneNum * frameIndex * 2;

// 3. 对每根影响当前顶点的骨骼进行处理
for (int i = 0; i < 4; i++) {
    int boneIndex = boneIndices[i];
    float weight = boneWeights[i];
    
    // 4. 采样动画纹理获取骨骼变换数据
    int pixelIndex = frameDataPixelIndex + boneIndex * 2;
    float4 rotation = tex2Dlod(_AnimationTex, indexToUV(pixelIndex));
    float4 translation = tex2Dlod(_AnimationTex, indexToUV(pixelIndex + 1));
    
    // 5. 四元数转换为矩阵
    float4x4 boneMatrix = DualQuaternionToMatrix(rotation, translation);
    
    // 6. 加权累加
    finalMatrix += boneMatrix * weight;
}

// 7. 应用最终变换矩阵
float4 positionOS = mul(finalMatrix, input.positionOS);
```

**关键技术点**：

1. **UV 坐标计算**（indexToUV）：
   ```hlsl
   float4 indexToUV(float index) {
       int iIndex = trunc(index + 0.5);
       int row = (int)(iIndex * _AnimationTex_TexelSize.x);
       float col = iIndex - row * _AnimationTex_TexelSize.z;
       // 添加 0.5 偏移到像素中心（Point 过滤模式必需）
       return float4((col+0.5)*_AnimationTex_TexelSize.x, 
                     (row+0.5)*_AnimationTex_TexelSize.y, 0, 0);
   }
   ```

2. **四元数转矩阵**（QuaternionToMatrix）：
   - 将存储的四元数旋转转换为 4×4 变换矩阵
   - 包含旋转、位移和缩放信息

3. **帧混合**（可选）：
   - 支持当前帧和下一帧的混合（_BlendFrameIndex 和 _BlendProgress）
   - 实现动画的平滑过渡

#### 顶点动画 Shader（GpuVerticesAnimation.shader）

```hlsl
// 1. 获取顶点索引（从 UV1）
float vertexIndex = input.vertexIndex.x;

// 2. 采样动画纹理
float2 uv = float2(vertexIndex / _AnimationTex_TexelSize.z, 
                   frameIndex / _AnimationTex_TexelSize.w);
float3 position = tex2Dlod(_AnimationTex, float4(uv, 0, 0)).xyz;
float3 normal = tex2Dlod(_AnimationNormalTex, float4(uv, 0, 0)).xyz;

// 3. 直接使用采样的位置和法线
output.positionCS = TransformObjectToHClip(float4(position, 1));
```

### 3.5 运行时动画控制

#### GPUSkinningAnimation 类

负责动画播放逻辑：
```csharp
public class GPUSkinningAnimation
{
    private float currentTime;          // 当前播放时间
    private GpuSkinningAnimClip currentClip;  // 当前动画片段
    private bool isLoop;                // 是否循环
    
    public void Update(float deltaTime) {
        currentTime += deltaTime * timeScale;
        
        // 计算当前帧索引
        float frameIndex = currentClip.startFrame + 
                          (currentTime / currentClip.getPerFrameDuration());
        
        // 循环或钳制
        if (frameIndex > currentClip.endFrame) {
            if (isLoop) {
                frameIndex = currentClip.startFrame + 
                            (frameIndex - currentClip.startFrame) % currentClip.Length();
            } else {
                frameIndex = currentClip.endFrame;
            }
        }
    }
}
```

#### 参数传递方式

项目提供了多种将动画参数传递到 Shader 的方式：

1. **直接设置 Material 属性**（基础方式）
   ```csharp
   material.SetInt("_FrameIndex", frameIndex);
   ```

2. **修改 Model 矩阵**（ModifyModelMatrixGPUSkinningAnimator）
   - 通过 transform.localScale 传递动画帧信息
   - 在 Shader 中从 UNITY_MATRIX_M 提取数据
   - 优点：不破坏 GPU Instancing

3. **MaterialPropertyBlock**（GPUSkinningAnimator）
   ```csharp
   materialPropertyBlock.SetVector("_AnimatorData", 
       new Vector3(frameIndex, blendFrameIndex, blendProgress));
   meshRenderer.SetPropertyBlock(materialPropertyBlock);
   ```
   - 优点：不破坏模型矩阵，支持 SRP Batcher
   - 可以让每个实例播放不同动画

4. **噪点图控制**（NoiseGpuVerticesAnimation）
   - 使用噪点纹理让不同位置的实例处于不同动画帧
   - 适合大规模场景（如草地、粒子）

## 四、数据压缩与优化

### 4.1 Float16 编码方案

为了在不支持 RGBAHalf 的设备上运行，项目实现了自定义的 Float16 编码：

- **格式**：1 位符号 + 7 位整数 + 8 位小数
- **范围**：-127 到 127
- **精度**：1/256 ≈ 0.0039

**编码过程**（convertFloat32toFloat16Bytes）：
```csharp
byte[] convertFloat32toFloat16Bytes(float srcValue) {
    int integer = (int)srcValue;
    float floats = srcValue - integer;
    
    // 符号位
    data[0] = srcValue > 0 ? 0 : 1;
    
    // 整数位（7位）
    // 将 integer 转二进制...
    
    // 小数位（8位）
    for (int i = 0; i < 8; i++) {
        floats *= 2;
        data[i] = (int)floats;
        floats -= (int)floats;
    }
    
    // 打包成 2 个字节
    return result;
}
```

**解码过程**（Shader 中的 convertFloat16BytesToHalf）：
```hlsl
float convertFloat16BytesToHalf(int data1, int data2) {
    int flag = data1 / 128;  // 符号位
    float result = (data1 - flag * 128) + (data2 / 256.0);
    result = result - 2 * flag * result;  // 应用符号
    return result;
}
```

### 4.2 帧率压缩

支持降低动画帧率来节省纹理内存：

```csharp
// 压缩率为 0.5 表示使用一半的帧数
float compression = 0.5f;
int clipFrame = (int)(clip.frameRate * clip.length / compression);
```

结合 Shader 中的帧混合，即使 15fps 的动画也能保持流畅。

### 4.3 纹理大小优化

- **骨骼动画**：纹理大小 = f(骨骼数 × 帧数)
  - 例：30 根骨骼，100 帧 → 6000 像素 → 128×64 纹理
  
- **顶点动画**：纹理大小 = 顶点数 × 帧数
  - 例：1000 顶点，100 帧 → 1000×100 纹理
  - **注意**：顶点动画纹理通常远大于骨骼动画

## 五、使用场景与性能特点

### 5.1 六个示例场景

1. **场景 0**：顶点动画 + 单个模型
2. **场景 1**：骨骼动画 + 单个模型
3. **场景 2**：骨骼动画 + GPU Instancing（大量相同模型）
4. **场景 3**：顶点动画 + 噪点图（不同位置不同帧）
5. **场景 4**：顶点动画 + 修改 Model 矩阵（支持帧混合和压缩）
6. **场景 5**：顶点动画 + MaterialPropertyBlock（最灵活的方式）

### 5.2 性能优势

| 传统方式 | GPU Skinning |
|---------|-------------|
| CPU 每帧计算骨骼矩阵 | GPU 采样预计算的纹理 |
| 每个实例独立 Draw Call | 支持 GPU Instancing |
| 内存占用小 | 需要额外的动画纹理 |
| 适合少量复杂模型 | 适合大量相同模型 |

**适用场景**：
- ✅ 大量相同角色的战斗场景（如 RTS、MOBA）
- ✅ 草地、树木等植被动画
- ✅ 粒子系统的复杂动画
- ❌ 单个高精度角色（传统方式更好）

### 5.3 限制与注意事项

1. **内存占用**：动画纹理会占用显存，需要权衡
2. **动画精度**：依赖纹理精度，可能有轻微误差
3. **网格要求**：
   - 所有子 Mesh 必须使用同一张主纹理
   - UV1 和 UV2 被用于骨骼数据，不能再用于其他用途
4. **不保留层级**：生成的 Prefab 是扁平化的单个 Mesh
5. **骨骼映射**：需要正确处理不同 SkinnedMeshRenderer 的骨骼索引映射

## 六、工作流程

### 6.1 导出流程

1. 在菜单栏选择 "Window" → "GpuSkinningTool"
2. 选择要转换的 FBX 模型
3. 选择要导出的动画片段
4. 选择生成类型（骨骼动画或顶点动画）
5. 设置压缩率（可选）
6. 检查纹理大小预览
7. 点击"生成"按钮

### 6.2 生成的资源

- **动画数据**：`xxx_Data.asset` 或 `xxx_VertData.asset`
- **动画纹理**：`xxx.animMap.asset`
- **法线纹理**：`xxx.animNormalMap.asset`（仅顶点动画）
- **Mesh**：`xxx_Mesh.asset` 或 `xxx_VertMesh.asset`
- **材质**：`xxx_Mat.mat`
- **Prefab**：`xxx_Pre.prefab`

### 6.3 运行时使用

```csharp
// 方式 1：使用 GpuSkinningInstance（简单）
GpuSkinningInstance instance = prefab.GetComponent<GpuSkinningInstance>();

// 方式 2：使用 GPUSkinningAnimator（高级）
GPUSkinningAnimator animator = prefab.GetComponent<GPUSkinningAnimator>();
animator.PlayAnimation("Run", loop: true);
animator.animatorSpeed = 1.5f;  // 播放速度

// 方式 3：使用 ModifyModelMatrixGPUSkinningAnimator
ModifyModelMatrixGPUSkinningAnimator animator = 
    prefab.GetComponent<ModifyModelMatrixGPUSkinningAnimator>();
animator.PlayAnimation("Attack", onEndHandler: () => {
    Debug.Log("Attack animation finished!");
});
```

## 七、技术演进历史

项目经历了多次重要更新，反映了技术的不断优化：

1. **2019/11/27**：从 RGBAHalf 改为 RGBA32，实现自定义 Float16 以支持 OpenGL ES2.0
2. **2019/12/01**：添加顶点动画支持，解决低配设备骨骼计算慢的问题
3. **2020/04/20**：从 MessagePack 二进制改为直接导出纹理，降低 GC 压力
4. **2021/05/03**：添加修改 Model 矩阵的方式，支持帧混合和补帧
5. **2021/06/03**：增加帧率压缩功能
6. **2022/09/04**：添加 URP 支持，使用 MaterialPropertyBlock，升级到 RGBAHalf

## 八、总结

这个项目是一个完整的 GPU Skinning 解决方案，核心思想是**用显存换性能**。通过将动画数据预烘焙到纹理中，将蒙皮计算从 CPU 转移到 GPU，特别适合需要渲染大量相同角色的场景。

**关键技术点**：
- 骨骼矩阵的预计算和纹理编码
- Shader 中的矩阵采样和顶点变换
- 多种参数传递方式以适配不同渲染管线
- Float16 自定义编码以提升兼容性
- 帧率压缩和帧混合以优化内存和视觉效果

**设计亮点**：
- 提供了 6 种不同的使用方式，覆盖各种使用场景
- 兼容性好，支持从 OpenGL ES2.0 到现代 URP
- 完善的编辑器工具，使用方便
- 详细的注释和文档，易于理解和扩展
